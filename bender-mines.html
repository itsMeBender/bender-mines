<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/render-status.html">

<dom-module id="bender-mines">
  <template>
    <style>
      :host {
        display: block;
        width: auto;
      }
      :host::after { 
        content: "";
        display: block; 
        clear: both;
      }
      .game-field {
        float: left;
        height: 16px;
        position: relative;
        width: 16px;
        text-align: center;
      }
      .game-field > span {
        display: inline-block;
        font-size: 0.7em;
        vertical-align: middle;
      }
      .game-field--untouched {
        background-color: greenyellow;
      }
      .game-field--explored {
        background-color: lightgray;
      }
      .game-field--flagged {
        background-color: red;
      }
      .game-grid {
        display: inline-block;
        width: auto;
      }
      .game-grid::after { 
        content: "";
        display: block; 
        clear: both;
      }
      .clear-left {
        clear: left;
      }

    </style>
    <!-- <h2>Settings [[fieldX]]&times;[[fieldY]] '[[game]]'.</h2> -->
    <div id="gamegrid" class="game-grid"></div>
    <slot id="graphics"></slot>
  </template>

  <script>
    /**
<img src="tile_flag.png" width="32" height="32">
  <img src="tile_grid.png" width="32" height="32">
  <img src="tile_mine.png" width="32" height="32">
  <img src="tile_visited.png" width="32" height="32">     * `bender-mines`
     * A simple game
     *
     * ```
     * <bender-mines field-x="8" field-y="8" game="easy"></bender-mines>
     * ```
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */

    const CLEAN = 0;
    const MINE = 1;
    const VISITED = 2;

    class BenderMines extends Polymer.Element {
      // https://stackoverflow.com/questions/24867741/polymer-global-variables

      static get is() { return 'bender-mines'; }

      static get properties() {
        return {
          fieldX: {
            type: Number,
            value: 5
          },

          fieldY: {
            type: Number,
            value: 5
          },

          game: {
            type: String,
            value: "easy"
          },
          
          // Play grid, with dimensions X*Y 
          _playField: {
            type: Array,
            value: []
          }
        };
      }

      static get observers() {
        return [
          'drawGameGrid(fieldX, fieldY, game)'
        ];
      }

connectedCallback() {
  let imgLst = [];

  // https://stackoverflow.com/questions/45585503/polymer-2-0-event-listeners-where-is-the-ideal-place-to-add-it
  // https://www.polymer-project.org/2.0/docs/upgrade#callback-contracts-have-changed
    super.connectedCallback();
    this.addEventListener('click', this.myFunction.bind(this));
    // Monitor the content of SLOT
    this._observer = new Polymer.FlattenedNodesObserver(this, function(info) {
      // info is {target: '...', addedNodes: [...], removedNodes: [...]}
      console.log('info', info);
      info.addedNodes.forEach((node) => {
        if (node.nodeName.toUpperCase() === 'IMG') {
          console.log(node.nodeName);
          imgLst.push(node);
        }
      });
      this._imgLst = imgLst;
    });
}

disconnectedCallback() {
    super.disconnetedCallback();
    this.removeEventListener('click', this.myFunction);
    this._observer.disconnect();
}
myFunction (me) {
  console.log('click:', me, this._imgLst);
}

      drawGameGrid(fieldX, fieldY, game) {
        console.log('drawGameGrid:', this._imgLst);
        this.game = this._validateGameDifficulty(game);
        this.fieldX = this._validateFieldSize(fieldX);
        this.fieldY = this._validateFieldSize(fieldY);

        // Prepare a single game session.
        this.randomizeGameGrid(this.game);
        this._eraseGrid();
        this._buildGrid();
        this._gameStart();
      }

      randomizeGameGrid(gameOption) {
        let difficulty = {'easy': 0.22, 'medium': 0.26, 'hard': 0.31}; // These are percentages
        let gameGridSize = this.fieldX * this.fieldY;
        let i = 0;
        let mines = Math.floor(difficulty[gameOption] * gameGridSize);

        this._playField = []; // Reset

        for (i; i < gameGridSize; i += 1) { // Build gameGrid without mines.
          this._playField.push(CLEAN);
        }

        while (mines > 0) { // Add these number of mines.
          let field = Math.floor(Math.random() * gameGridSize); // 0 .. (gameGridSize - 1)
          if (this._playField[field] === CLEAN) {
            this._playField[field] = MINE;
            mines -= 1;
          }
        }
      }

      /**
       * Build the initial gamegrid with elements
       */
      _buildGrid() {
        const grid = this.$.gamegrid;
        let row;
        let x = this.fieldX;
        let __debug = ''; // TODO: Remove functionallity

        this._playField.forEach((value, idx) => {
          let element = document.createElement('DIV');
          let elementSpan = document.createElement('SPAN');
          let elementText = document.createTextNode('');  // Don't show anything (mine count)

          // #gamegrid > DIV#field[number] > SPAN 'surrounding mines count'
          elementSpan.appendChild(elementText);
          element.appendChild(elementSpan);

          element.setAttribute('id', `field${idx}`);
          element.classList.add('game-field', 'game-field--untouched');

          // Start a new ROW of game fields
          if (row !== Math.floor(idx / x)) {
            row = Math.floor(idx / x); // 0, 1, 2, ...
            element.classList.add('clear-left');
            console.log(__debug);
            __debug = '';
          }
          __debug += value;
          grid.appendChild(element);
        });
        console.log(__debug); // See console for a mines grid
        console.log(this._playField);
      }

      _cleanGameGrid(startField) {
        let element = this.$.gamegrid.querySelector(`#field${startField}`);
        let mineCount;
        let scanGrid = this._getScanGridFive(startField); // Only field UP, DOWN, LEFT, RIGHT and center

        element.classList.remove('game-field--untouched');
        element.classList.add('game-field--explored');

        mineCount = this._countMines(startField);
        if (mineCount === 0) {
          element.querySelector('SPAN').innerHTML = " ";
        } else {
          element.querySelector('SPAN').innerHTML = mineCount;
        }
        this._playField[startField] = VISITED;

        // Start / part of the recursion
        scanGrid.forEach((fieldNo) => {
          if (this._playField[fieldNo] === CLEAN) {
            this._cleanGameGrid(fieldNo);
          }
        });
      }

      _countMines(fieldNo) {
        let center = this._fieldNoToCoordinates(fieldNo);
        let coordinate = {};
        let mines = 0;
        let scanGrid = this._getScanGridNine(fieldNo);

        scanGrid.forEach((scanGridField, idx) => {
          if (this._playField[scanGridField] === MINE) {
            mines += 1;
          }
        });

        return mines;
      }

      /**
       * Erase (if) existing gamegrid.
       */
      _eraseGrid() {
        let grid = this.$.gamegrid;
        while (grid.firstChild) {
          grid.removeChild(grid.firstChild);
        }
      }

      _gameStart() {
        let border = this._getBorder(); // Array of coordinates game grid border
        let field;
        let startField;

        do {
          field = Math.floor(Math.random() * border.length);
          field = border[field];
          console.log('random:', field);
          if (this._playField[field] !== MINE) {
            startField = field;
          }
        } while (!startField);

        // Create start situation.
        this._cleanGameGrid(startField);
      }

      _getBorder() {
        let border = new Set(); // To avoid duplicates.
        let row;
        let x = this.fieldX;
        let y = this.fieldY - 1;

        this._playField.forEach((value, idx) => {
          row = Math.floor(idx / x);
          // First and last row of the game grid
          if (row === 0 || row === y) {
            border.add(idx);
          }
          // First and last column of the game grid
          if (row > 0 && idx % x === 0 ) {
            border.add(idx); // Left column
            border.add(idx - 1); // Right column
          }
        });

        return Array.from(border); // From a Set to an Array.
      }

      _getScanGrid(fieldNo, scanGrid) {
        let center = this._fieldNoToCoordinates(fieldNo);
        let coordinate = {};
        let validScanGrid = [];

        return scanGrid.filter(scanGridField => {
          // Validate grid coordinates
          coordinate = this._fieldNoToCoordinates(scanGridField);
          if (
            coordinate.x < center.x - 1 ||
            coordinate.x > center.x + 1 ||
            coordinate.y < center.y - 1 ||
            coordinate.y > center.y + 1 ||
            coordinate.x >= this.fieldX ||
            coordinate.y >= this.fieldY ||
            coordinate.x < 0 ||
            coordinate.y < 0
          ) {
            return false; // ScanGrid partly outside game grid, so next Array item.
          } else {
            return true;
          }
        });
      }

      _getScanGridNine(fieldNo) {
        return this._getScanGrid(fieldNo, [ // Grid 3x3, center is field
          (fieldNo - 1 - this.fieldX), (fieldNo - this.fieldX), (fieldNo + 1 - this.fieldX),
          (fieldNo - 1              ),                 fieldNo, (fieldNo + 1),
          (fieldNo - 1 + this.fieldX), (fieldNo + this.fieldX), (fieldNo + 1 + this.fieldX),
        ]);
      }

      _getScanGridFive(fieldNo) {
        return this._getScanGrid(fieldNo, [ // Grid horizontal and vertical center is field
          (fieldNo - this.fieldX),
          (fieldNo - 1), fieldNo, (fieldNo + 1),
          (fieldNo + this.fieldX)
        ]);
      }

      _fieldNoToCoordinates(field) {
        let x = field % this.fieldX;
        let y = Math.floor(field / this.fieldX);
        return {'x': x, 'y': y};
      }
      
      /**
       * Validates the size of the game rectangle. Which must be within the range of 5 and 5 * 4. If fails default 5 is returned.
       * @param {number} size of a single side game rectangle
       * @returns a valid (default) game difficult level [].
       */
      _validateFieldSize(size) {
        let standard = 5;
        size = size || standard;
        if (size < standard || size > standard * 4) {
          size = 5;
        }
        return size;
      }

      /**
       * @param {string} game level enumerated by ['easy', 'medium', 'hard']
       * @returns a valid (default) game difficult level [].
       */
      _validateGameDifficulty(game) {
        let doEasy = 'easy';

        game = game || doEasy;
        game = game.toLowerCase();
        switch (game) {
          case 'easy':
          case 'medium':
          case 'hard':
            break;
          default:
            game = doEasy;
        }
        return game;
      }
    }

    window.customElements.define(BenderMines.is, BenderMines);
  </script>
</dom-module>
